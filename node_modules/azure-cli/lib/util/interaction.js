/*** Generated by streamline 0.10.17 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb; var __ = require("underscore");
















var tty = require("tty");
var fs = require("fs");
var util = require("util");
var tty = require("tty");


var child_process = require("child_process");

var log = require("./logging");

function Interactor(cli) {
  this.cli = cli;
  this.istty1 = tty.isatty(1);

  this.initProgressBars();};


__.extend(Interactor.prototype, {
  initProgressBars: function() {
    var self = this;
    self.progressChars = ["-","\\","|","/",];
    self.progressIndex = 0;

    self.clearBuffer = new Buffer(79, "utf8");
    self.clearBuffer.fill(" ");
    self.clearBuffer = self.clearBuffer.toString(); },



  drawAndUpdateProgress: function() {
    var self = this;

    fs.writeSync(1, "\r");
    process.stdout.write(self.progressChars[self.progressIndex].cyan);

    self.progressIndex++;
    if ((self.progressIndex === self.progressChars.length)) {
      self.progressIndex = 0; } ; },



  clearProgress: function() {
    var self = this;


    if (self.currentProgress) {
      if (self.activeProgressTimer) {
        clearInterval(self.activeProgressTimer);
        self.activeProgressTimer = null; } ;

      fs.writeSync(1, "\r+\n");
      self.currentProgress = undefined; } ; },



  writeDuringProgress: function(level, message) {
    if (this.currentProgress) {
      fs.writeSync(1, (("\r" + this.clearBuffer) + "\r"));
      log[level](message);
      this.drawAndUpdateProgress(); } ; },



  pauseProgress: function() {
    if (this.currentProgress) {
      fs.writeSync(1, (("\r" + this.clearBuffer) + "\r")); } ; },



  restartProgress: function(label) {
    if (this.currentProgress) {
      this.drawAndUpdateProgress();
      if (label) {
        fs.writeSync(1, (" " + label)); } ; } ; },




  progress: function(label, log) {
    var self = this;
    if ((!log && self.cli)) {
      log = self.cli.output; } ;


    var verbose = (log && (((log.format().json || (log.format().level === "verbose")) || (log.format().level === "silly"))));
    if ((!self.istty1 || verbose)) {
      ((verbose ? log.verbose : log.info))(label);
      return {
        write: function(logAction) {
          logAction(); },

        end: function() {  } }; } ;




    self.clearProgress();


    fs.writeSync(1, ("\r" + self.clearBuffer));


    self.drawAndUpdateProgress();


    if (label) {
      fs.writeSync(1, (" " + label)); } ;


    self.activeProgressTimer = setInterval(function() {
      self.drawAndUpdateProgress();
    }, 200);

    self.currentProgress = {
      write: function(logAction, newLabel) {
        newLabel = (newLabel || label);
        self.pauseProgress();
        logAction();
        self.restartProgress(newLabel); },

      end: function() {
        self.clearProgress(); } };



    return self.currentProgress; },


  withProgress: function(label, action, callback) {
    var self = this;
    var p = this.progress(label);
    var logMsgs = [];
    var logger = {
      error: function(message) {
        logMsgs.push(function() { self.cli.output.error(message); }); },

      info: function(message) {
        logMsgs.push(function() { self.cli.output.info(message); }); },

      data: function(message) {
        logMsgs.push(function() { self.cli.output.data(message); }); },

      warn: function(message) {
        logMsgs.push(function() { self.cli.output.warn(message); }); } };



    action.call(p, logger, function() {
      p.end();
      logMsgs.forEach(function(lf) { lf(); });
      callback.apply(null, arguments); }); },



  prompt: function(msg, callback) {
    this.cli.prompt(msg, function(result) {
      callback(null, result); }); },



  confirm: function(msg, callback) {
    this.cli.confirm(msg, function(ok) {
      callback(null, ok); }); },



  promptPassword: function(msg, callback) {
    this.password(msg, "*", function(result) {
      callback(null, result); }); },



  promptPasswordIfNotGiven: function promptPasswordIfNotGiven__1(promptString, currentValue, _) { var value, __this = this; var __frame = { name: "promptPasswordIfNotGiven__1", line: 190 }; return __func(_, this, arguments, promptPasswordIfNotGiven__1, 2, __frame, function __$promptPasswordIfNotGiven__1() { return (function __$promptPasswordIfNotGiven__1(__then) {
        if (__.isUndefined(currentValue)) {
          return __this.promptPassword(promptString, __cb(_, __frame, 2, 23, function ___(__0, __1) { value = __1;
            return _(null, value); }, true)); } else {

          return _(null, currentValue); } ; })(_); }); },



  promptPasswordOnce: function(msg, callback) {
    this.passwordOnce(msg, "*", function(result) {
      callback(null, result); }); },



  promptPasswordOnceIfNotGiven: function promptPasswordOnceIfNotGiven__2(promptString, currentValue, _) { var value, __this = this; var __frame = { name: "promptPasswordOnceIfNotGiven__2", line: 205 }; return __func(_, this, arguments, promptPasswordOnceIfNotGiven__2, 2, __frame, function __$promptPasswordOnceIfNotGiven__2() { return (function __$promptPasswordOnceIfNotGiven__2(__then) {
        if (__.isUndefined(currentValue)) {
          return __this.promptPasswordOnce(promptString, __cb(_, __frame, 2, 23, function ___(__0, __1) { value = __1;
            return _(null, value); }, true)); } else {

          return _(null, currentValue); } ; })(_); }); },



  promptIfNotGiven: function promptIfNotGiven__3(promptString, currentValue, _) { var value, __this = this; var __frame = { name: "promptIfNotGiven__3", line: 214 }; return __func(_, this, arguments, promptIfNotGiven__3, 2, __frame, function __$promptIfNotGiven__3() { return (function __$promptIfNotGiven__3(__then) {
        if (__.isUndefined(currentValue)) {
          return __this.prompt(promptString, __cb(_, __frame, 2, 23, function ___(__0, __1) { value = __1;
            return _(null, value); }, true)); } else {

          return _(null, currentValue); } ; })(_); }); },



  choose: function(values, callback) {
    this.cli.choose(values, function(value) {
      callback(null, value); }); },



  chooseIfNotGiven: function chooseIfNotGiven__4(promptString, progressString, currentValue, valueProvider, _) { var progress, values, i, __this = this; var __frame = { name: "chooseIfNotGiven__4", line: 229 }; return __func(_, this, arguments, chooseIfNotGiven__4, 4, __frame, function __$chooseIfNotGiven__4() { return (function __$chooseIfNotGiven__4(__then) {
        if (__.isUndefined(currentValue)) {
          progress = __this.cli.interaction.progress(progressString);
          return valueProvider(__cb(_, __frame, 3, 19, function ___(__0, __1) { values = __1;
            progress.end();

            __this.cli.output.help(promptString);
            return __this.choose(values, __cb(_, __frame, 7, 19, function ___(__0, __2) { i = __2;
              return _(null, values[i]); }, true)); }, true)); } else {

          return _(null, currentValue); } ; })(_); }); },



  formatOutput: function(outputData, humanOutputGenerator) {
    this.cli.output.json("silly", outputData);
    if (this.cli.output.format().json) {
      this.cli.output.json(outputData); }
     else {
      humanOutputGenerator(outputData); } ; },



  logEachData: function(title, data) {
    for (var property in data) {
      if (data.hasOwnProperty(property)) {
        if (data[property]) {
          this.cli.output.data(((title + " ") + property), data[property]); }
         else {
          this.cli.output.data(((title + " ") + property), ""); } ; } ; }; },





  launchBrowser: function launchBrowser__5(url, _) { var cmd; var __frame = { name: "launchBrowser__5", line: 264 }; return __func(_, this, arguments, launchBrowser__5, 1, __frame, function __$launchBrowser__5() {
      log.info("Launching browser to", url); return (function __$launchBrowser__5(__then) {
        if ((process.env.OS !== undefined)) {

          cmd = util.format("start %s", url).replace(/&/g, "^&");
          return child_process.exec(cmd, __cb(_, __frame, 5, 20, __then, true)); } else {

          child_process.spawn("open", [url,]); __then(); } ; })(_); }); },



  passwordOnce: function(currentStr, mask, callback) {
    var buf = "";


    if (("function" === typeof mask)) {
      callback = mask;
      mask = ""; } ;


    if (!process.stdin.setRawMode) {
      process.stdin.setRawMode = tty.setRawMode; } ;


    process.stdin.resume();
    process.stdin.setRawMode(true);
    fs.writeSync((this.istty1 ? 1 : 2), currentStr);

    process.stdin.on("data", function(character) {

      character = character.toString();
      if ((character === "")) {
        console.log("%s", buf);
        process.exit(); } ;



      if ((character === "\r")) {
        process.stdin.pause();
        process.stdin.removeAllListeners("data");
        process.stdout.write("\n");
        process.stdin.setRawMode(false);

        return callback(buf); } ;




      if (((character === "") || (character === ""))) {
        if (buf) {
          buf = buf.slice(0, -1);
          for (var j = 0; (j < mask.length); ++j) {
            process.stdout.write(" "); }; } ;



        return; } ;


      character = character.split("\r")[0];
      for (var i = 0; (i < character.length); ++i) {
        process.stdout.write(mask); };


      buf += character; }); },




  password: function(str, mask, fn) {
    var self = this;


    this.passwordOnce(str, mask, function(pass) {

      self.passwordOnce("Confirm password: ", mask, function(pass2) {
        if ((pass === pass2)) {
          fn(pass); }
         else {
          throw new Error("Passwords do not match."); } ; }); }); }});






module.exports = Interactor;
